<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'] ], displayMath: [ ['$$','$$'], [&#34;\\[&#34;,&#34;\\]&#34;] ] } });  Pyroによる確率モデリング #  前節で「Pyroにより確率変数やそれらを組み合わせた確率モデルを容易に扱うことが可能になる」ことを述べました。本節ではもう少し詳しくPyroがどのように確率変数や確率モデルを扱うのかをみていきたいと思います。
Pyroでは大きく２つの構成要素により確率変数や確率モデルを扱います。１つが確率プリミティブ。もう１つが確率モデルのハンドラであるpoutineです。以下でそれぞれ詳しくみていきましょう。
以降、前節の手順でpyroがインストールされ、以下のimportが実行されている前提で話を進めます。
import matplotlib.pyplot as plt import pyro import pyro.distributions as dist from pyro.poutine import trace ■確率プリミティブ #  一般的にベイズ学習において確率モデルは確率的に実現値が変動する「確率変数」の組み合わせで構成されます。そしてPyro上で確率変数を宣言するものが確率プリミティブです。
確率変数の宣言 #  例えば平均0で標準偏差が1のガウス分布に従う確率変数$X$を考える時、Pyroでは$X$を
x = pyro.sample(&#34;X&#34;, dist.Normal(0, 1)) print(x) ## Output # tensor(0.0784) のようにpyro.sampleを用いて宣言します。ここで第一引数は確率変数名を宣言しており、後に行う推論などではこの名前を確率変数のIDとして処理を行います（そのために一意に命名する必要があります。）。第二引数は確率変数$X$の従う確率分布を指定しており、今回は正規分布のNormalを用いています。 また、pyro.sample関数は指定された確率分布にしたがって値をサンプリングする関数となっており、python変数であるxにはサンプリングされた実現値が代入されることになります（2行目print文）。
確率変数$X$から独立同分布(i.i.d)で実現値をサンプリングしたければ、以下のコード例のようにpyro.sample文をforループを回すことで可能です。
x_list = [] for _ in range(10000): x = pyro.sample(&#34;X&#34;, dist.Normal(0, 1)) x_list.append(x) plt."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Pyroによる確率モデリング"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://pyro-book.data-hacker.net/docs/pyro_modeling/"><title>Pyroによる確率モデリング | Pyroで実践するベイズ機械学習</title><link rel=manifest href=https://pyro-book.data-hacker.net/manifest.json><link rel=icon href=https://pyro-book.data-hacker.net/favicon.png type=image/x-icon><link rel=stylesheet href=https://pyro-book.data-hacker.net/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=https://pyro-book.data-hacker.net/en.search.min.84f2074ed3734b2299510c6e4c231ea14a261d28f214cb2bfb980db97691872a.js integrity="sha256-hPIHTtNzSyKZUQxuTCMeoUomHSjyFMsr+5gNuXaRhyo="></script><script defer src=https://pyro-book.data-hacker.net/sw.min.74a8bb07f0bee86d6bb9a2750f073f14d93c7e4512f28860370cfd879e9719b4.js integrity="sha256-dKi7B/C+6G1ruaJ1Dwc/FNk8fkUS8ohgNwz9h56XGbQ="></script><link rel=alternate type=application/rss+xml href=https://pyro-book.data-hacker.net/docs/pyro_modeling/index.xml title=Pyroで実践するベイズ機械学習></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=https://pyro-book.data-hacker.net/><span>Pyroで実践するベイズ機械学習</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://pyro-book.data-hacker.net/docs/what_is_pyro/>Pyroとは</a></li><li><a href=https://pyro-book.data-hacker.net/docs/pyro_modeling/ class=active>Pyroによる確率モデリング</a></li><li><a href=https://pyro-book.data-hacker.net/docs/dist_basic/>確率分布の取り扱い</a></li><li><a href=https://pyro-book.data-hacker.net/docs/bayes_learning_basic/>ベイズ学習の枠組み</a></li><li><a href=https://pyro-book.data-hacker.net/docs/vi_basic/>変分推論の基礎</a></li><li><a href=https://pyro-book.data-hacker.net/docs/pyro_vi/>Pyroでの変分推論</a></li><li><a href=https://pyro-book.data-hacker.net/docs/mle_map/>MAP推定と最尤推定</a></li><li><a href=https://pyro-book.data-hacker.net/docs/linear_regression/>ベイズ線形回帰</a></li><li><a href=https://pyro-book.data-hacker.net/docs/model_selection_01/>モデル選択:周辺尤度最大化</a><br><br></li></ul><ul><li><a href=https://github.com/a-mitani/bayes-pyro target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://pyro-book.data-hacker.net/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Pyroによる確率モデリング</strong>
<label for=toc-control><img src=https://pyro-book.data-hacker.net/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#pyroによる確率モデリング>Pyroによる確率モデリング</a><ul><li><a href=#確率プリミティブ>■確率プリミティブ</a><ul><li><a href=#確率変数の宣言>確率変数の宣言</a></li><li><a href=#plateを用いたサンプリング><code>plate</code>を用いたサンプリング</a></li><li><a href=#確率モデルの宣言>確率モデルの宣言</a></li><li><a href=#複雑な確率モデル>複雑な確率モデル</a></li></ul></li><li><a href=#エフェクトハンドラ-poutine>■エフェクト・ハンドラ <code>poutine</code></a><ul><li><a href=#確率モデル挙動の記録-trace>確率モデル挙動の記録 <code>Trace</code></a></li><li><a href=#条件付け-condition>条件付け <code>condition</code></a></li><li><a href=#確率変数の隠蔽-block>確率変数の隠蔽 <code>block</code></a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type=text/x-mathjax-config>
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script><h1 id=pyroによる確率モデリング>Pyroによる確率モデリング
<a class=anchor href=#pyro%e3%81%ab%e3%82%88%e3%82%8b%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%aa%e3%83%b3%e3%82%b0>#</a></h1><p>前節で「Pyroにより確率変数やそれらを組み合わせた確率モデルを容易に扱うことが可能になる」ことを述べました。本節ではもう少し詳しくPyroがどのように確率変数や確率モデルを扱うのかをみていきたいと思います。</p><p>Pyroでは大きく２つの構成要素により確率変数や確率モデルを扱います。１つが<strong>確率プリミティブ</strong>。もう１つが確率モデルのハンドラである<strong>poutine</strong>です。以下でそれぞれ詳しくみていきましょう。</p><p>以降、前節の手順でpyroがインストールされ、以下の<code>import</code>が実行されている前提で話を進めます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
<span style=color:#f92672>import</span> pyro
<span style=color:#f92672>import</span> pyro.distributions <span style=color:#f92672>as</span> dist
<span style=color:#f92672>from</span> pyro.poutine <span style=color:#f92672>import</span> trace
</code></pre></div><h2 id=確率プリミティブ>■確率プリミティブ
<a class=anchor href=#%e7%a2%ba%e7%8e%87%e3%83%97%e3%83%aa%e3%83%9f%e3%83%86%e3%82%a3%e3%83%96>#</a></h2><p>一般的にベイズ学習において確率モデルは確率的に実現値が変動する「確率変数」の組み合わせで構成されます。そしてPyro上で確率変数を宣言するものが<strong>確率プリミティブ</strong>です。</p><h3 id=確率変数の宣言>確率変数の宣言
<a class=anchor href=#%e7%a2%ba%e7%8e%87%e5%a4%89%e6%95%b0%e3%81%ae%e5%ae%a3%e8%a8%80>#</a></h3><p>例えば平均0で標準偏差が1のガウス分布に従う確率変数$X$を考える時、Pyroでは$X$を</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>x <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;X&#34;</span>, dist<span style=color:#f92672>.</span>Normal(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
<span style=color:#66d9ef>print</span>(x)
<span style=color:#75715e>## Output</span>
<span style=color:#75715e># tensor(0.0784)</span>
</code></pre></div><p>のように<code>pyro.sample</code>を用いて宣言します。ここで第一引数は確率変数名を宣言しており、後に行う推論などではこの名前を確率変数のIDとして処理を行います（そのために一意に命名する必要があります。）。第二引数は確率変数$X$の従う確率分布を指定しており、今回は正規分布の<code>Normal</code>を用いています。
また、<code>pyro.sample</code>関数は指定された確率分布にしたがって値をサンプリングする関数となっており、python変数である<code>x</code>にはサンプリングされた実現値が代入されることになります（2行目<code>print</code>文）。</p><p>確率変数$X$から独立同分布(i.i.d)で実現値をサンプリングしたければ、以下のコード例のように<code>pyro.sample</code>文をforループを回すことで可能です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>x_list <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10000</span>):
    x <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;X&#34;</span>, dist<span style=color:#f92672>.</span>Normal(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
    x_list<span style=color:#f92672>.</span>append(x)
plt<span style=color:#f92672>.</span>hist(x_list, bins<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)
</code></pre></div><center><img src=norm_hist.png width=300></center><h3 id=plateを用いたサンプリング><code>plate</code>を用いたサンプリング
<a class=anchor href=#plate%e3%82%92%e7%94%a8%e3%81%84%e3%81%9f%e3%82%b5%e3%83%b3%e3%83%97%e3%83%aa%e3%83%b3%e3%82%b0>#</a></h3><p>確率変数から多数のサンプリングを行う場合、上記のようにforループを用いてシーケンシャルにサンプリングを行うことは計算効率がよくありません。そこでPyroでは効率よくサンプリングを行うために<code>pyro.plate</code>というコンテキストマネージャが用意されており、上記のFor文によるサンプリングと同様のことを下記のコードで行うことができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>with</span> pyro<span style=color:#f92672>.</span>plate(<span style=color:#e6db74>&#34;plate1&#34;</span>, size<span style=color:#f92672>=</span><span style=color:#ae81ff>10000</span>):
    samples <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;samples&#34;</span>, dist<span style=color:#f92672>.</span>Normal(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;var_type is {}, shape = {}&#34;</span><span style=color:#f92672>.</span>format(type(samples), samples<span style=color:#f92672>.</span>shape))
plt<span style=color:#f92672>.</span>hist(samples, bins<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)
<span style=color:#75715e>## Output</span>
<span style=color:#75715e># var_type is &lt;class &#39;torch.Tensor&#39;&gt;, shape = torch.Size([10000])</span>
</code></pre></div><p>当然ですが出力されるヒストグラムもFor文の結果と同様の形になります。</p><center><img src=norm_hist2.png width=300></center><p><code>pyro.plate</code>はそのコンテキスト内でサンプルされた事象はお互いに独立であることをPyroに明示的に伝える役割があります。このことは特に推論時の処理時間に非常に大きな影響を与えます。なぜなら独立である場合はサンプリング時に並列処理を行うことができるからです。</p><p>実際に手元の処理時間を比較すると、For文によるサンプリングが0.72秒で、<code>plate</code>を利用した場合は0.003秒と200倍以上の速度差がでました。<code>plate</code>で得られた変数値はサンプル数だけ要素を持った１つのtorch.Tensor型の変数に格納されていることにも注意してください。</p><p>以上のことからそれぞれ独立にサンプルする場合は積極的に<code>pyro.plate</code>を用いることが推奨されます。</p><h3 id=確率モデルの宣言>確率モデルの宣言
<a class=anchor href=#%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab%e3%81%ae%e5%ae%a3%e8%a8%80>#</a></h3><p>確率モデルは、確率プリミティブの演算の組み合わせで構成された<strong>Python関数として宣言</strong>します。</p><p>簡単な確率モデルをPyroで定義する例をみてみましょう。ここでは以下のような例を考えます。</p><p><strong>例:赤玉白玉問題</strong> 下図のように、２つの袋$a$および$b$があり、袋$a$には赤玉が2個、白玉が1個入っており、袋$b$には赤玉が1個、白玉が3個入っているものとします。ここで、２つの袋のうち一方の袋を等確率にランダムに選び、その選んだ袋から玉を１つ取り出す試行を行います。</p><center><img src=ball.001.png width=300></center>
ここで「袋が選ばれる」「玉が取り出される」という確率的な過程をそれぞれ確率変数$X$、$Y$とすると上の試行は下記のグラフィカルモデルのように記述出来ます。
<center><img src=ball.002.png width=300></center><p>この確率モデルは下記の<code>ball_model</code>のようなpython関数として定義することができます。4行目では確率変数$X$の分布を<code>p=0.5</code>のベルヌーイ分布を指定しています。ここで確率変数$X$の実現値が1の場合は袋aを、0の場合は袋bが選ばれたものとします。そして選ばれた袋（確率変数の実現値）に応じて、確率変数$Y$の確率分布がスイッチし、それぞれの袋の中の赤玉と白玉の数に合わせてベルヌーイ分布の確率が指定されています。確率変数$Y$の実現値が1の場合は赤玉を、0の場合は白玉が取り出されたものとします。</p><p>ちなみに、このように観測値（今回の場合は取り出した玉の色）がどのような確率過程で生み出されたのかを記述するようなモデルを<strong>生成モデル</strong>と呼ばれます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># x=1: 袋a,  x=0: 袋b</span>
<span style=color:#75715e># y=1: 赤玉, y=0:　白玉</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ball_model</span>():
    x <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;X&#34;</span>, dist<span style=color:#f92672>.</span>Bernoulli(<span style=color:#ae81ff>0.5</span>))
    <span style=color:#66d9ef>if</span> x:  
        y <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;Y&#34;</span>, dist<span style=color:#f92672>.</span>Bernoulli(<span style=color:#ae81ff>2.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>3.0</span>))
    <span style=color:#66d9ef>else</span>: 
        y <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;Y&#34;</span>, dist<span style=color:#f92672>.</span>Bernoulli(<span style=color:#ae81ff>1.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>4.0</span>))
    <span style=color:#66d9ef>return</span> y
</code></pre></div><p>確率プリミティブの組み合わせで構成された<code>ball_model</code>の関数もやはり確率的な挙動を示す確率的関数として動作し、下記のコード例のように、関数が呼ばれたらその関数内で定義されたモデルに従って値をサンプリングする動作をします。（もちろん<code>pyro.plate</code>を用いたサンプリングも可能です<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
    <span style=color:#66d9ef>print</span>(ball_model())
<span style=color:#75715e>## output</span>
<span style=color:#75715e># tensor(0.)</span>
<span style=color:#75715e># tensor(0.)</span>
<span style=color:#75715e># tensor(1.)</span>
<span style=color:#75715e># tensor(0.)</span>
<span style=color:#75715e># tensor(1.)</span>
</code></pre></div><h3 id=複雑な確率モデル>複雑な確率モデル
<a class=anchor href=#%e8%a4%87%e9%9b%91%e3%81%aa%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab>#</a></h3><p>確率モデルをPythonの関数の形で書けることは、今後さらに複雑な確率モデルを考えていく上で非常に便利な特徴です。Pythonの関数と同様に、確率モデルに引数を渡したり、再帰的な確率モデルを構築することも容易ですし、関数同士を組み合わせることも可能です。（下記コード例参照）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>geometric</span>(p, t<span style=color:#f92672>=</span>None):
    <span style=color:#66d9ef>if</span> t <span style=color:#f92672>is</span> None:
        t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    x <span style=color:#f92672>=</span> pyro<span style=color:#f92672>.</span>sample(<span style=color:#e6db74>&#34;x_{}&#34;</span><span style=color:#f92672>.</span>format(t), pyro<span style=color:#f92672>.</span>distributions<span style=color:#f92672>.</span>Bernoulli(p))
    <span style=color:#66d9ef>if</span> x<span style=color:#f92672>.</span>item() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>else</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> geometric(p, t <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)

<span style=color:#66d9ef>print</span>(geometric(<span style=color:#ae81ff>0.5</span>))

<span style=color:#75715e>## output</span>
<span style=color:#75715e># 0</span>
</code></pre></div><h2 id=エフェクトハンドラ-poutine>■エフェクト・ハンドラ <code>poutine</code>
<a class=anchor href=#%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%83%8f%e3%83%b3%e3%83%89%e3%83%a9-poutine>#</a></h2><p>ここまでで、確率モデルをPythonの関数として実装し、その確率モデルに従ったサンプリングを行うことができました。ベイズ推論などを行っていく際には、その確率モデルの挙動を記録したり、挙動を修正（e.g.条件付けなど）など確率モデルをハンドリングする必要があります。そのようなハンドリング機能を担うのが<code>poutine</code>モジュールです。ここでは<code>poutine</code>のモジュールの中でよく利用されるものを紹介します。</p><h3 id=確率モデル挙動の記録-trace>確率モデル挙動の記録 <code>Trace</code>
<a class=anchor href=#%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab%e6%8c%99%e5%8b%95%e3%81%ae%e8%a8%98%e9%8c%b2-trace>#</a></h3><p>ベイズ推論を行う際には実現値を出力するに至るまでに確率モデルの内部の確率変数がどういう値を取ったのかを知りたい場合が多くあります。Pyroでは<code>Trace</code>オブジェクトが確率モデルをサンプルした際の挙動を記録する役割を担います。<code>Trace</code>オブジェクトは下記コードのようにして取得します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>traced_model <span style=color:#f92672>=</span> poutine<span style=color:#f92672>.</span>trace(model_fn) <span style=color:#75715e># TraceMessengerオブジェクトを取得</span>
trace <span style=color:#f92672>=</span> traced_model<span style=color:#f92672>.</span>get_trace() <span style=color:#75715e># Traceオブジェクトを取得</span>
</code></pre></div><p>1行目で対象とする確率モデルの<code>TraceMessenger</code>オブジェクトを<code>traced_model</code>の名前で取得し、2行目の<code>get_trace</code>でサンプリングとそのサンプリング時の確率モデルの内部状態を<code>Trace</code>オブジェクトに記録しています。ここで対象の確率モデル関数が引数を持つ場合はget_traceの引数に指定することで引数に応じたサンプリングを行います。</p><p><code>Trace</code>オブジェクトは有向グラフの形式で確率モデルのサンプリング状態を記録しており、その有向グラフは確率モデルのインプットとアウトプット、そしてモデル内の確率変数をノードとして持ちます。例として以下のコードように<code>ball_model</code>の内部状態を出力してみます。
この出力内容を見ると、<code>ball_model</code>には関数内で明示的に定義した<code>'X'</code>, <code>'Y'</code>に加えて<code>'_INPUT'</code>、<code>'_RETURN'</code>ノードが存在することがわかります。また今回のモデルの実現値は内部のそれぞれの確率変数の実現値（<code>value</code>）が<code>'X'=tensor(0.)</code>、<code>'Y'=tensor(1.)</code>となることでモデルの最終的な出力<code>'_RETURN'</code>の実現値が<code>tensor(1.)</code>となっていることが窺い知ることができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>tr <span style=color:#f92672>=</span> trace(ball_model)<span style=color:#f92672>.</span>get_trace()
<span style=color:#66d9ef>for</span> tr_items <span style=color:#f92672>in</span> tr<span style=color:#f92672>.</span>nodes<span style=color:#f92672>.</span>items():
    <span style=color:#66d9ef>print</span>(tr_items)
<span style=color:#75715e># output</span>
<span style=color:#75715e># (&#39;_INPUT&#39;, {&#39;name&#39;: &#39;_INPUT&#39;, &#39;type&#39;: &#39;args&#39;, &#39;args&#39;: (), &#39;kwargs&#39;: {}})</span>
<span style=color:#75715e># (&#39;X&#39;, {&#39;type&#39;: &#39;sample&#39;, &#39;name&#39;: &#39;X&#39;, &#39;fn&#39;: Bernoulli(probs: 0.5), &#39;is_observed&#39;: False, &#39;args&#39;: (), &#39;kwargs&#39;: {}, &#39;value&#39;: tensor(0.), &#39;infer&#39;: {}, &#39;scale&#39;: 1.0, &#39;mask&#39;: None, &#39;cond_indep_stack&#39;: (), &#39;done&#39;: True, &#39;stop&#39;: False, &#39;continuation&#39;: None})</span>
<span style=color:#75715e># (&#39;Y&#39;, {&#39;type&#39;: &#39;sample&#39;, &#39;name&#39;: &#39;Y&#39;, &#39;fn&#39;: Bernoulli(probs: 0.25), &#39;is_observed&#39;: False, &#39;args&#39;: (), &#39;kwargs&#39;: {}, &#39;value&#39;: tensor(1.), &#39;infer&#39;: {}, &#39;scale&#39;: 1.0, &#39;mask&#39;: None, &#39;cond_indep_stack&#39;: (), &#39;done&#39;: True, &#39;stop&#39;: False, &#39;continuation&#39;: None})</span>
<span style=color:#75715e># (&#39;_RETURN&#39;, {&#39;name&#39;: &#39;_RETURN&#39;, &#39;type&#39;: &#39;return&#39;, &#39;value&#39;: tensor(1.)})</span>
</code></pre></div><h3 id=条件付け-condition>条件付け <code>condition</code>
<a class=anchor href=#%e6%9d%a1%e4%bb%b6%e4%bb%98%e3%81%91-condition>#</a></h3><p><code>condition</code>ハンドラを用いてモデル内の各確率変数の実現値を固定（条件付け）してサンプリングを行うことが可能になります。条件付けはkeyを確率変数名、valueを固定する実現値としたdictionary型で<code>condition</code>ハンドラに渡します。</p><p>この<code>condition</code>ハンドラを用いると、例えば、確率モデルの全ての確率変数の実現値を固定した上でサンプリングし、その確率を求めると同時確率を求めらます。以下に、ball_modelにおいて「袋aが選ばれ、赤玉が得られる」場合の同時確率、つまり$p(X=1, Y=1)$を求める例を示します。</p><p>ここで、最後の<code>tr.log_prob_sum()</code>はモデル内の各確率変数の対数確率の和を出力する関数です。つまりこの例では
$$
ln(p(X=1))+ln(p(Y=1))
$$
を計算してることに注意してください。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>ond_dict <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;X&#34;</span>: torch<span style=color:#f92672>.</span>tensor(<span style=color:#ae81ff>1.</span>), <span style=color:#e6db74>&#34;Y&#34;</span>: torch<span style=color:#f92672>.</span>tensor(<span style=color:#ae81ff>1.</span>)} <span style=color:#75715e># 袋a=1, 赤玉=1 </span>
conditioned_model <span style=color:#f92672>=</span> condition(ball_model, cond_dict)

tr <span style=color:#f92672>=</span> trace(conditioned_model)<span style=color:#f92672>.</span>get_trace()
<span style=color:#66d9ef>for</span> tr_items <span style=color:#f92672>in</span> tr<span style=color:#f92672>.</span>nodes<span style=color:#f92672>.</span>items():
    <span style=color:#66d9ef>print</span>(tr_items)

<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;p(X=1, Y=1) =&#39;</span>,  tr<span style=color:#f92672>.</span>log_prob_sum()<span style=color:#f92672>.</span>exp()<span style=color:#f92672>.</span>item())

<span style=color:#75715e>## Output</span>
<span style=color:#75715e># (&#39;_INPUT&#39;, {&#39;name&#39;: &#39;_INPUT&#39;, &#39;type&#39;: &#39;args&#39;, &#39;args&#39;: (), &#39;kwargs&#39;: {}})</span>
<span style=color:#75715e># (&#39;X&#39;, {&#39;type&#39;: &#39;sample&#39;, &#39;name&#39;: &#39;X&#39;, &#39;fn&#39;: Bernoulli(probs: 0.5), &#39;is_observed&#39;: True, &#39;args&#39;: (), &#39;kwargs&#39;: {}, &#39;value&#39;: tensor(1.), &#39;infer&#39;: {}, &#39;scale&#39;: 1.0, &#39;mask&#39;: None, &#39;cond_indep_stack&#39;: (), &#39;done&#39;: True, &#39;stop&#39;: False, &#39;continuation&#39;: None})</span>
<span style=color:#75715e># (&#39;Y&#39;, {&#39;type&#39;: &#39;sample&#39;, &#39;name&#39;: &#39;Y&#39;, &#39;fn&#39;: Bernoulli(probs: 0.6666666865348816), &#39;is_observed&#39;: True, &#39;args&#39;: (), &#39;kwargs&#39;: {}, &#39;value&#39;: tensor(1.), &#39;infer&#39;: {}, &#39;scale&#39;: 1.0, &#39;mask&#39;: None, &#39;cond_indep_stack&#39;: (), &#39;done&#39;: True, &#39;stop&#39;: False, &#39;continuation&#39;: None})</span>
<span style=color:#75715e># (&#39;_RETURN&#39;, {&#39;name&#39;: &#39;_RETURN&#39;, &#39;type&#39;: &#39;return&#39;, &#39;value&#39;: tensor(1.)})</span>
<span style=color:#75715e># p(X=1, Y=1) = 0.3333333134651184</span>
</code></pre></div><p>上記の出力結果から指定された条件付けに基づいてサンプリングされ、また計算された同時確率$p(X=1, Y=1) = 0.333&mldr;$はモデルから解析的に得られる値
$$
p(X=1, Y=1) = p(X=1)P(Y=1) = \frac{1}{2} * \frac{2}{3} = \frac{1}{3}
$$
と一致していることがわかります。</p><h3 id=確率変数の隠蔽-block>確率変数の隠蔽 <code>block</code>
<a class=anchor href=#%e7%a2%ba%e7%8e%87%e5%a4%89%e6%95%b0%e3%81%ae%e9%9a%a0%e8%94%bd-block>#</a></h3><p><code>block</code>ハンドラを用いると、モデル内の指定された確率変数から隠蔽されます。これは例え以下のコードのように<code>condition</code>と組み合わせて条件付き確率（$p(X=1|Y=1$）を求めたい時に使うことができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>cond_dict <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;X&#34;</span>: torch<span style=color:#f92672>.</span>tensor(<span style=color:#ae81ff>1.</span>), <span style=color:#e6db74>&#34;Y&#34;</span>: torch<span style=color:#f92672>.</span>tensor(<span style=color:#ae81ff>1.</span>)} <span style=color:#75715e># 袋a=1, 赤玉=1 </span>
conditioned_model <span style=color:#f92672>=</span> condition(ball_model, cond_dict)
blocked_model <span style=color:#f92672>=</span> block(conditioned_model, hide<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;X&#34;</span>])

tr <span style=color:#f92672>=</span> trace(blocked_model)<span style=color:#f92672>.</span>get_trace()
<span style=color:#66d9ef>for</span> tr_items <span style=color:#f92672>in</span> tr<span style=color:#f92672>.</span>nodes<span style=color:#f92672>.</span>items():
    <span style=color:#66d9ef>print</span>(tr_items)

<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;p(Y=1|X=1) =&#39;</span>,  tr<span style=color:#f92672>.</span>log_prob_sum()<span style=color:#f92672>.</span>exp()<span style=color:#f92672>.</span>item())

<span style=color:#75715e># Output</span>
<span style=color:#75715e># &#39;_INPUT&#39;, {&#39;name&#39;: &#39;_INPUT&#39;, &#39;type&#39;: &#39;args&#39;, &#39;args&#39;: (), &#39;kwargs&#39;: {}})</span>
<span style=color:#75715e># (&#39;Y&#39;, {&#39;type&#39;: &#39;sample&#39;, &#39;name&#39;: &#39;Y&#39;, &#39;fn&#39;: Bernoulli(probs: 0.6666666865348816), &#39;is_observed&#39;: True, &#39;args&#39;: (), &#39;kwargs&#39;: {}, &#39;value&#39;: tensor(1.), &#39;infer&#39;: {}, &#39;scale&#39;: 1.0, &#39;mask&#39;: None, &#39;cond_indep_stack&#39;: (), &#39;done&#39;: True, &#39;stop&#39;: False, &#39;continuation&#39;: None})</span>
<span style=color:#75715e># (&#39;_RETURN&#39;, {&#39;name&#39;: &#39;_RETURN&#39;, &#39;type&#39;: &#39;return&#39;, &#39;value&#39;: tensor(1.)})</span>
<span style=color:#75715e># p(Y=1|X=1) = 0.6666666269302368</span>
</code></pre></div><blockquote class="book-hint info"><p><strong>Tips</strong></p><p>Pyroにおける確率モデルのハンドリングする仕組みとして<code>poutine</code>を用いて同時確率や条件付き確率を計算する手法を紹介しました。読者によってはコードが少々回りくどい印象を受けるかもしれません。</p><p>実際のところは<code>poutine</code>モジュールは、Pyroの推論モジュールから呼ばれる前提で設計されており、ユーザー自身が<code>poutine</code>を用いて確率モデルをハンドルすることはほとんどありません。</p></blockquote><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><code>plate</code>を用いる場合は、Tensorの演算を行うためmodelにif分岐を使えない制約があるためIF文を用いずに等価なモデルを記述する必要があります。ball_modelの場合の実装例を
<a href=https://gist.github.com/a-mitani/630ef831e8f2238da003a23f25d75e2e>Gistに載せた</a>ので参照ください。 <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#pyroによる確率モデリング>Pyroによる確率モデリング</a><ul><li><a href=#確率プリミティブ>■確率プリミティブ</a><ul><li><a href=#確率変数の宣言>確率変数の宣言</a></li><li><a href=#plateを用いたサンプリング><code>plate</code>を用いたサンプリング</a></li><li><a href=#確率モデルの宣言>確率モデルの宣言</a></li><li><a href=#複雑な確率モデル>複雑な確率モデル</a></li></ul></li><li><a href=#エフェクトハンドラ-poutine>■エフェクト・ハンドラ <code>poutine</code></a><ul><li><a href=#確率モデル挙動の記録-trace>確率モデル挙動の記録 <code>Trace</code></a></li><li><a href=#条件付け-condition>条件付け <code>condition</code></a></li><li><a href=#確率変数の隠蔽-block>確率変数の隠蔽 <code>block</code></a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>